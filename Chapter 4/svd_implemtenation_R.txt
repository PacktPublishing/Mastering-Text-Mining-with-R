# List of packages for the sessionpackages = c("foreach", "doParallel", "irlba")# Install CRAN packages (if not already installed)inst <- packages %in% installed.packages()if(length(packages[!inst]) > 0) install.packages(packages[!inst])# Load packages into session lapply(packages, require, character.only=TRUE)# register the parallel session for registerDoParallel(cores=detectCores(all.tests=TRUE))std_svd <- function(x, k, p=25, iter=0 1 ) { m1 <- as.matrix(x)r <- nrow(m1)c <- ncol(m1)p <- min( min(r,c)-k,p)z <- k+pm2 <- matrix ( rnorm(z*c), nrow=c, ncol=z)y <- m1 %*% m2q <- qr.Q(qr(y))b<- t(q) %*% m1#iterationsb1<-foreach( i=i1:iter ) %dopar% {   y1 <- m1 %*% t(b)  q1 <- qr.Q(qr(y1))  b1 <- t(q1) %*% m1}b1<-b1[[iter]]b2 <- b1 %*% t(b1)eigens <- eigen(b2, symmetric=T)result <- list()result$svalues <- sqrt(eigens$values)[1:k]u1=eigens$vectors[1:k,1:k]result$u <- (q %*% eigens$vectors)[,1:k]result$v <- (t(b) %*% eigens$vectors %*% diag(1/eigens$values))[,1:k]return(result)}svd<- std_svd(x=data,k=5))# singular vectorssvd$svalues




#######A modified version for the previous function can be achieved by ###altering the power iterations for a robust implementation:foreach( i = 1:iter )%dopar% {   y1 <- m1 %*% t(b)  y2 <- t(y1) %*% y1  r2 <- chol(y2, pivot = T)  q1 <- y2 %*% solve(r2)  b1 <- t(q1) %*% m1}b2 <- b1 %*% t(b1)